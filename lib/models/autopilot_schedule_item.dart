import 'package:cloud_firestore/cloud_firestore.dart';

/// Trigger types for autopilot schedule items.
enum AutopilotTrigger {
  holiday,
  gameDay,
  sunset,
  sunrise,
  weeknight,
  weekend,
  seasonal,
  learned,
  custom,
}

/// A single scheduled item generated by Lumina Autopilot.
///
/// Contains all the information needed to apply a lighting pattern
/// at a specific time, including the reason for the suggestion and
/// confidence score.
class AutopilotScheduleItem {
  /// Unique identifier for this schedule item.
  final String id;

  /// When this pattern should be applied.
  final DateTime scheduledTime;

  /// Days of the week to repeat (e.g., ['Mon', 'Wed', 'Fri']).
  /// Empty list means one-time occurrence.
  final List<String> repeatDays;

  /// Name of the pattern to apply.
  final String patternName;

  /// Optional pattern ID from the library.
  final String? patternId;

  /// Human-readable reason for this suggestion.
  /// e.g., "Chiefs game tonight" or "Christmas Day"
  final String reason;

  /// What triggered this schedule item.
  final AutopilotTrigger trigger;

  /// Confidence score from 0.0 to 1.0.
  /// Higher means Lumina is more confident the user will like this.
  final double confidenceScore;

  /// The WLED JSON payload ready to be sent to the device.
  final Map<String, dynamic> wledPayload;

  /// Primary colors for this pattern (for UI display).
  final List<int>? colors;

  /// Effect ID if using a WLED built-in effect.
  final int? effectId;

  /// Palette ID if using a WLED palette.
  final int? paletteId;

  /// When this suggestion was created.
  final DateTime createdAt;

  /// When this item was last modified.
  final DateTime? updatedAt;

  /// Whether this item has been approved by the user.
  final bool isApproved;

  /// Whether this item was auto-applied (autonomyLevel == 2).
  final bool wasAutoApplied;

  /// Associated event name (e.g., "Christmas", "Chiefs vs Raiders").
  final String? eventName;

  /// Duration in minutes before auto-off (null = no auto-off).
  final int? durationMinutes;

  const AutopilotScheduleItem({
    required this.id,
    required this.scheduledTime,
    required this.repeatDays,
    required this.patternName,
    this.patternId,
    required this.reason,
    required this.trigger,
    required this.confidenceScore,
    required this.wledPayload,
    this.colors,
    this.effectId,
    this.paletteId,
    required this.createdAt,
    this.updatedAt,
    this.isApproved = false,
    this.wasAutoApplied = false,
    this.eventName,
    this.durationMinutes,
  });

  /// Create from Firestore document.
  factory AutopilotScheduleItem.fromJson(Map<String, dynamic> json) {
    return AutopilotScheduleItem(
      id: json['id'] as String,
      scheduledTime: json['scheduled_time'] is Timestamp
          ? (json['scheduled_time'] as Timestamp).toDate()
          : DateTime.parse(json['scheduled_time'] as String),
      repeatDays: (json['repeat_days'] as List?)?.cast<String>() ?? const [],
      patternName: json['pattern_name'] as String,
      patternId: json['pattern_id'] as String?,
      reason: json['reason'] as String,
      trigger: AutopilotTrigger.values.firstWhere(
        (e) => e.name == json['trigger'],
        orElse: () => AutopilotTrigger.custom,
      ),
      confidenceScore: (json['confidence_score'] as num?)?.toDouble() ?? 0.5,
      wledPayload: Map<String, dynamic>.from(json['wled_payload'] as Map? ?? {}),
      colors: (json['colors'] as List?)?.cast<int>(),
      effectId: json['effect_id'] as int?,
      paletteId: json['palette_id'] as int?,
      createdAt: json['created_at'] is Timestamp
          ? (json['created_at'] as Timestamp).toDate()
          : DateTime.parse(json['created_at'] as String),
      updatedAt: json['updated_at'] != null
          ? (json['updated_at'] is Timestamp
              ? (json['updated_at'] as Timestamp).toDate()
              : DateTime.parse(json['updated_at'] as String))
          : null,
      isApproved: json['is_approved'] as bool? ?? false,
      wasAutoApplied: json['was_auto_applied'] as bool? ?? false,
      eventName: json['event_name'] as String?,
      durationMinutes: json['duration_minutes'] as int?,
    );
  }

  /// Convert to Firestore document.
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'scheduled_time': Timestamp.fromDate(scheduledTime),
      'repeat_days': repeatDays,
      'pattern_name': patternName,
      if (patternId != null) 'pattern_id': patternId,
      'reason': reason,
      'trigger': trigger.name,
      'confidence_score': confidenceScore,
      'wled_payload': wledPayload,
      if (colors != null) 'colors': colors,
      if (effectId != null) 'effect_id': effectId,
      if (paletteId != null) 'palette_id': paletteId,
      'created_at': Timestamp.fromDate(createdAt),
      if (updatedAt != null) 'updated_at': Timestamp.fromDate(updatedAt!),
      'is_approved': isApproved,
      'was_auto_applied': wasAutoApplied,
      if (eventName != null) 'event_name': eventName,
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
    };
  }

  /// Create a copy with updated fields.
  AutopilotScheduleItem copyWith({
    String? id,
    DateTime? scheduledTime,
    List<String>? repeatDays,
    String? patternName,
    String? patternId,
    String? reason,
    AutopilotTrigger? trigger,
    double? confidenceScore,
    Map<String, dynamic>? wledPayload,
    List<int>? colors,
    int? effectId,
    int? paletteId,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isApproved,
    bool? wasAutoApplied,
    String? eventName,
    int? durationMinutes,
  }) {
    return AutopilotScheduleItem(
      id: id ?? this.id,
      scheduledTime: scheduledTime ?? this.scheduledTime,
      repeatDays: repeatDays ?? this.repeatDays,
      patternName: patternName ?? this.patternName,
      patternId: patternId ?? this.patternId,
      reason: reason ?? this.reason,
      trigger: trigger ?? this.trigger,
      confidenceScore: confidenceScore ?? this.confidenceScore,
      wledPayload: wledPayload ?? this.wledPayload,
      colors: colors ?? this.colors,
      effectId: effectId ?? this.effectId,
      paletteId: paletteId ?? this.paletteId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isApproved: isApproved ?? this.isApproved,
      wasAutoApplied: wasAutoApplied ?? this.wasAutoApplied,
      eventName: eventName ?? this.eventName,
      durationMinutes: durationMinutes ?? this.durationMinutes,
    );
  }

  /// Check if this schedule item should fire at the given time.
  bool shouldFireAt(DateTime time) {
    // Check if it's the right time of day
    if (time.hour != scheduledTime.hour || time.minute != scheduledTime.minute) {
      return false;
    }

    // If no repeat days, check exact date
    if (repeatDays.isEmpty) {
      return time.year == scheduledTime.year &&
          time.month == scheduledTime.month &&
          time.day == scheduledTime.day;
    }

    // Check if today is a repeat day
    final dayName = _dayOfWeekName(time.weekday);
    return repeatDays.contains(dayName);
  }

  String _dayOfWeekName(int weekday) {
    const names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    return names[weekday - 1];
  }

  /// Get a human-readable description of when this fires.
  String get scheduleDescription {
    final timeStr = '${scheduledTime.hour.toString().padLeft(2, '0')}:${scheduledTime.minute.toString().padLeft(2, '0')}';

    if (repeatDays.isEmpty) {
      // One-time event
      final monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return '${monthNames[scheduledTime.month - 1]} ${scheduledTime.day} at $timeStr';
    }

    if (repeatDays.length == 7) {
      return 'Daily at $timeStr';
    }

    if (repeatDays.length == 5 &&
        repeatDays.contains('Mon') &&
        repeatDays.contains('Tue') &&
        repeatDays.contains('Wed') &&
        repeatDays.contains('Thu') &&
        repeatDays.contains('Fri')) {
      return 'Weekdays at $timeStr';
    }

    if (repeatDays.length == 2 &&
        repeatDays.contains('Sat') &&
        repeatDays.contains('Sun')) {
      return 'Weekends at $timeStr';
    }

    return '${repeatDays.join(", ")} at $timeStr';
  }

  @override
  String toString() =>
      'AutopilotScheduleItem(id: $id, pattern: $patternName, trigger: ${trigger.name}, confidence: ${(confidenceScore * 100).toStringAsFixed(0)}%)';
}

/// Extension to get display properties for triggers.
extension AutopilotTriggerExtension on AutopilotTrigger {
  String get displayName {
    switch (this) {
      case AutopilotTrigger.holiday:
        return 'Holiday';
      case AutopilotTrigger.gameDay:
        return 'Game Day';
      case AutopilotTrigger.sunset:
        return 'Sunset';
      case AutopilotTrigger.sunrise:
        return 'Sunrise';
      case AutopilotTrigger.weeknight:
        return 'Weeknight';
      case AutopilotTrigger.weekend:
        return 'Weekend';
      case AutopilotTrigger.seasonal:
        return 'Seasonal';
      case AutopilotTrigger.learned:
        return 'Learned';
      case AutopilotTrigger.custom:
        return 'Custom';
    }
  }

  String get icon {
    switch (this) {
      case AutopilotTrigger.holiday:
        return 'üéâ';
      case AutopilotTrigger.gameDay:
        return 'üèà';
      case AutopilotTrigger.sunset:
        return 'üåÖ';
      case AutopilotTrigger.sunrise:
        return 'üåÑ';
      case AutopilotTrigger.weeknight:
        return 'üåô';
      case AutopilotTrigger.weekend:
        return 'üéä';
      case AutopilotTrigger.seasonal:
        return 'üçÇ';
      case AutopilotTrigger.learned:
        return 'üß†';
      case AutopilotTrigger.custom:
        return '‚ú®';
    }
  }
}
