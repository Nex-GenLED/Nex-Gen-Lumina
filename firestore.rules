rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check ownership
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // Helper function to check if the authenticated user has media/admin access
    // Media users can view any customer's data for content creation purposes
    function hasMediaAccess() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.user_role in ['media', 'dealer', 'admin'];
    }

    // Helper function to check if user can read another user's data
    // Either the owner OR a user with media access privileges
    function canReadUserData(userId) {
      return isOwner(userId) || hasMediaAccess();
    }

    // SECURITY: Prevent tampering with critical fields
    function cannotModifyCriticalFields() {
      return request.resource.data.owner_id == resource.data.owner_id &&
             request.resource.data.id == resource.data.id &&
             request.resource.data.email.lower() == resource.data.email.lower();
    }

    // SECURITY: Validate dealer email is from authorized domain
    function isValidDealerEmail(email) {
      // Only allow emails from verified dealer domains
      // Update this list with your authorized dealer domains
      return email == null ||
             email.matches('.*@nexgenled.com') ||
             email.matches('.*@authorized-dealer.com');
    }

    // Helper function to check if user is a primary user of any installation
    function isPrimaryUser() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.installation_role == 'primary';
    }

    // Helper function to check if user is an installer
    function isInstaller() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.installation_role == 'installer';
    }

    // Helper function to check if user is an admin
    function isAdmin() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.installation_role == 'admin';
    }

    // Helper function to check if user belongs to a specific installation
    function belongsToInstallation(installationId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.installation_id == installationId;
    }

    // Helper function to check if user is the primary user of a specific installation
    function isPrimaryUserOfInstallation(installationId) {
      return request.auth != null &&
             exists(/databases/$(database)/documents/installations/$(installationId)) &&
             get(/databases/$(database)/documents/installations/$(installationId)).data.primary_user_id == request.auth.uid;
    }

    // User profiles - private to each user, but readable by media/dealer/admin roles
    match /users/{userId} {
      // Media users can read any user profile for content creation
      allow read: if canReadUserData(userId);

      // SECURITY: On create, enforce owner_id matches auth uid
      allow create: if isOwner(userId) &&
                      request.resource.data.owner_id == userId &&
                      request.resource.data.id == userId &&
                      isValidDealerEmail(request.resource.data.get('dealer_email', null));

      // SECURITY: On update, prevent tampering with critical fields
      allow update: if isOwner(userId) &&
                      cannotModifyCriticalFields() &&
                      isValidDealerEmail(request.resource.data.get('dealer_email', null));

      allow delete: if isOwner(userId);

      // SECURITY: AI usage tracking subcollection
      match /ai_usage/{usageId} {
        // Users can read their own usage data
        allow read: if isOwner(userId);

        // Users can create usage events (logged by client)
        allow create: if isOwner(userId) &&
          request.resource.data.keys().hasAll(['timestamp', 'status']);

        // No updates or deletes (usage is append-only for auditing)
        allow update, delete: if false;
      }

      // Controllers subcollection - WLED devices registered to user
      match /controllers/{controllerId} {
        // Users can read their own controllers, media users can view for content
        allow read: if canReadUserData(userId);

        // Users can create controllers (from device discovery/setup)
        allow create: if isOwner(userId);

        // Users can update their controllers (rename, IP changes, etc.)
        allow update: if isOwner(userId);

        // Users can delete their controllers
        allow delete: if isOwner(userId);
      }

      // Schedules subcollection - automation schedules for lighting
      match /schedules/{scheduleId} {
        // Users can read their own schedules, media users can view for content
        allow read: if canReadUserData(userId);

        // Users can create schedules
        allow create: if isOwner(userId);

        // Users can update their schedules
        allow update: if isOwner(userId);

        // Users can delete their schedules
        allow delete: if isOwner(userId);
      }

      // Commands subcollection - Cloud Relay commands for remote WLED control
      match /commands/{commandId} {
        // Users can read their own commands, media users can view system state
        allow read: if canReadUserData(userId);

        // Users can create commands (sent from app when remote)
        allow create: if isOwner(userId);

        // Users can update commands (status updates from relay)
        allow update: if isOwner(userId);

        // Users can delete commands (cleanup)
        allow delete: if isOwner(userId);
      }

      // Geofences subcollection - location-based automation triggers
      match /geofences/{geofenceId} {
        // Users can read their own geofences, media users can view for content
        allow read: if canReadUserData(userId);

        // Users can create geofences
        allow create: if isOwner(userId);

        // Users can update their geofences
        allow update: if isOwner(userId);

        // Users can delete their geofences
        allow delete: if isOwner(userId);
      }
    }
    
    // Sites - private to each user
    match /sites/{siteId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.owner_id;
    }
    
    // Device configurations - private to each user
    match /devices/{deviceId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.owner_id;
    }

    // ==================== Learning System Collections ====================

    // Pattern Usage Tracking - append-only logs with retention
    match /users/{userId}/pattern_usage/{usageId} {
      // Users can read their own usage data
      allow read: if isOwner(userId);

      // Users can create usage events
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['created_at', 'source']) &&
        request.resource.data.created_at is timestamp &&
        request.resource.data.source is string;

      // SECURITY: Allow deletion only for old records (90+ days for retention policy)
      // This allows cleanup functions to work
      allow delete: if isOwner(userId) &&
        resource.data.created_at < request.time - duration.value(90, 'd');

      // No updates (usage is append-only for auditing)
      allow update: if false;
    }

    // Favorites Collection
    match /users/{userId}/favorites/{favoriteId} {
      // Users can read their own favorites
      allow read: if isOwner(userId);

      // Users can create favorites
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['pattern_name', 'added_at']) &&
        request.resource.data.pattern_name is string &&
        request.resource.data.added_at is timestamp;

      // Users can update their favorites (usage count, last_used)
      allow update: if isOwner(userId) &&
        request.resource.data.pattern_name == resource.data.pattern_name &&
        request.resource.data.added_at == resource.data.added_at;

      // Users can delete their favorites
      allow delete: if isOwner(userId);
    }

    // Smart Suggestions Collection
    match /users/{userId}/suggestions/{suggestionId} {
      // Users can read their own suggestions
      allow read: if isOwner(userId);

      // Users can create suggestions (from client-side learning)
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['created_at', 'type', 'title']) &&
        request.resource.data.created_at is timestamp;

      // Users can update to dismiss suggestions
      allow update: if isOwner(userId) &&
        request.resource.data.dismissed == true;

      // Users can delete old suggestions
      allow delete: if isOwner(userId);
    }

    // Detected Habits Collection
    match /users/{userId}/detected_habits/{habitId} {
      // Users can read their detected habits
      allow read: if isOwner(userId);

      // Users can create habits (from client-side analysis)
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['detected_at', 'type', 'description']) &&
        request.resource.data.detected_at is timestamp;

      // No updates (habits are immutable once detected)
      allow update: if false;

      // SECURITY: Allow deletion for old habits (90+ days for retention policy)
      allow delete: if isOwner(userId) &&
        resource.data.detected_at < request.time - duration.value(90, 'd');
    }

    // Pattern Feedback subcollection (user's own feedback)
    match /users/{userId}/pattern_feedback/{feedbackId} {
      // Users can read their own feedback
      allow read: if isOwner(userId);

      // Users can create feedback
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['pattern_name', 'rating', 'created_at']) &&
        request.resource.data.rating is int &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5;

      // No updates or deletes (feedback is append-only for consistency)
      allow update, delete: if false;
    }

    // ==================== Global Analytics Collections ====================
    // These collections aggregate anonymized data across all users

    // Global Pattern Statistics
    match /analytics/global_pattern_stats/patterns/{patternId} {
      // Anyone can read trending patterns (public data)
      allow read: if request.auth != null;

      // Authenticated users can contribute stats (increment counters)
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['pattern_name', 'total_applications']);

      // No deletes (only Cloud Functions can clean up)
      allow delete: if false;

      // User tracking subcollection (hashed IDs for uniqueness)
      match /users/{hashedUserId} {
        allow read: if false; // Private tracking data
        allow write: if request.auth != null; // Any auth user can update
        allow delete: if false;
      }
    }

    // Pattern Feedback Aggregation
    match /analytics/pattern_feedback/patterns/{patternId} {
      // Anyone can read feedback stats
      allow read: if request.auth != null;

      // Authenticated users can contribute feedback
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['pattern_name', 'total_ratings']);

      allow delete: if false;

      // Anonymous rater tracking
      match /raters/{hashedUserId} {
        allow read: if false;
        allow write: if request.auth != null;
        allow delete: if false;
      }
    }

    // Pattern Requests
    match /analytics/pattern_requests/requests/{requestId} {
      // Anyone can read pattern requests
      allow read: if request.auth != null;

      // Authenticated users can create requests
      allow create: if request.auth != null &&
        request.resource.data.keys().hasAll(['requested_theme', 'created_at', 'vote_count', 'fulfilled']) &&
        request.resource.data.vote_count == 1 &&
        request.resource.data.fulfilled == false;

      // Users can vote (increment vote_count)
      allow update: if request.auth != null &&
        request.resource.data.vote_count == resource.data.vote_count + 1;

      // No deletes (only admins via Cloud Functions)
      allow delete: if false;

      // Voter tracking
      match /voters/{hashedUserId} {
        allow read: if false;
        allow write: if request.auth != null;
        allow delete: if false;
      }
    }

    // Color Trends
    match /analytics/color_trends/weekly/{weekId} {
      // Anyone can read color trends
      allow read: if request.auth != null;

      // Authenticated users can contribute color usage
      allow create, update: if request.auth != null;

      allow delete: if false;
    }

    // Effect Popularity
    match /analytics/effect_popularity/effects/{effectId} {
      // Anyone can read effect popularity
      allow read: if request.auth != null;

      // Authenticated users can contribute effect usage
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['effect_id', 'usage_count']);

      allow delete: if false;
    }

    // Trending Reports (generated by Cloud Functions)
    match /analytics/trending_reports/{reportId} {
      // Anyone can read reports
      allow read: if request.auth != null;

      // Only Cloud Functions can create reports
      allow write: if false;
    }

    // SECURITY: OAuth codes and refresh tokens collections (server-side only)
    match /oauth_codes/{codeId} {
      allow read, write: if false; // Only Cloud Functions can access
    }

    match /oauth_refresh_tokens/{tokenId} {
      allow read, write: if false; // Only Cloud Functions can access
    }

    // ==================== Installer Mode Collections ====================

    // Dealers collection - managed by admins
    match /dealers/{dealerCode} {
      // Authenticated users can read dealers (for validation during installer login)
      allow read: if request.auth != null;

      // Only admins can manage dealers
      allow create, update, delete: if hasMediaAccess() &&
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.user_role == 'admin';
    }

    // Installers collection - managed by dealers/admins
    match /installers/{installerId} {
      // Authenticated users can read installers (for PIN validation)
      allow read: if request.auth != null;

      // Dealers can manage their own installers, admins can manage all
      allow create, update, delete: if hasMediaAccess();
    }

    // Installation records - created during customer setup
    match /installations/{installationId} {
      // Users who belong to this installation can read it, plus media/dealer/admin
      allow read: if belongsToInstallation(installationId) || hasMediaAccess() || isAdmin();

      // Installers and admins can create installation records
      allow create: if (isInstaller() || isAdmin()) &&
        request.resource.data.keys().hasAll(['primary_user_id', 'dealer_code', 'installer_code', 'installed_at']);

      // Primary users of this installation can update it, plus admins
      allow update: if isPrimaryUserOfInstallation(installationId) || isAdmin();

      // Only admins can delete installations
      allow delete: if isAdmin();

      // Sub-users subcollection - managed by primary users
      match /subUsers/{subUserId} {
        // Anyone in the installation can read sub-users list
        allow read: if belongsToInstallation(installationId) || hasMediaAccess();

        // Primary users of this installation can manage sub-users
        allow create, update, delete: if isPrimaryUserOfInstallation(installationId) || isAdmin();
      }
    }

    // ==================== Invitations Collection ====================

    // Invitations - for inviting sub-users to join an installation
    match /invitations/{invitationId} {
      // Primary user who created the invitation can read it
      // Invitee (by email) can also read it to accept
      allow read: if request.auth != null && (
        resource.data.primary_user_id == request.auth.uid ||
        resource.data.invitee_email == request.auth.token.email ||
        isAdmin()
      );

      // Primary users can create invitations for their installation
      allow create: if request.auth != null && isPrimaryUser() &&
        request.resource.data.keys().hasAll(['installation_id', 'primary_user_id', 'invitee_email', 'token', 'expires_at', 'status', 'permissions']) &&
        request.resource.data.primary_user_id == request.auth.uid &&
        request.resource.data.status == 'pending';

      // Invitee can update (accept) the invitation
      // Primary user can update (revoke) the invitation
      allow update: if request.auth != null && (
        resource.data.invitee_email == request.auth.token.email ||
        resource.data.primary_user_id == request.auth.uid ||
        isAdmin()
      );

      // Primary user can delete their invitations
      allow delete: if request.auth != null && (
        resource.data.primary_user_id == request.auth.uid ||
        isAdmin()
      );
    }
  }
}
