rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper function to check ownership
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    // SECURITY: Prevent tampering with critical fields
    function cannotModifyCriticalFields() {
      return request.resource.data.owner_id == resource.data.owner_id &&
             request.resource.data.id == resource.data.id &&
             request.resource.data.email == resource.data.email;
    }

    // SECURITY: Validate dealer email is from authorized domain
    function isValidDealerEmail(email) {
      // Only allow emails from verified dealer domains
      // Update this list with your authorized dealer domains
      return email == null ||
             email.matches('.*@nexgenled.com') ||
             email.matches('.*@authorized-dealer.com');
    }

    // User profiles - private to each user
    match /users/{userId} {
      allow read: if isOwner(userId);

      // SECURITY: On create, enforce owner_id matches auth uid
      allow create: if isOwner(userId) &&
                      request.resource.data.owner_id == userId &&
                      request.resource.data.id == userId &&
                      isValidDealerEmail(request.resource.data.get('dealer_email', null));

      // SECURITY: On update, prevent tampering with critical fields
      allow update: if isOwner(userId) &&
                      cannotModifyCriticalFields() &&
                      isValidDealerEmail(request.resource.data.get('dealer_email', null));

      allow delete: if isOwner(userId);

      // SECURITY: AI usage tracking subcollection
      match /ai_usage/{usageId} {
        // Users can read their own usage data
        allow read: if isOwner(userId);

        // Users can create usage events (logged by client)
        allow create: if isOwner(userId) &&
          request.resource.data.keys().hasAll(['timestamp', 'status']);

        // No updates or deletes (usage is append-only for auditing)
        allow update, delete: if false;
      }

      // Controllers subcollection - WLED devices registered to user
      match /controllers/{controllerId} {
        // Users can read their own controllers
        allow read: if isOwner(userId);

        // Users can create controllers (from device discovery/setup)
        allow create: if isOwner(userId);

        // Users can update their controllers (rename, IP changes, etc.)
        allow update: if isOwner(userId);

        // Users can delete their controllers
        allow delete: if isOwner(userId);
      }

      // Schedules subcollection - automation schedules for lighting
      match /schedules/{scheduleId} {
        // Users can read their own schedules
        allow read: if isOwner(userId);

        // Users can create schedules
        allow create: if isOwner(userId);

        // Users can update their schedules
        allow update: if isOwner(userId);

        // Users can delete their schedules
        allow delete: if isOwner(userId);
      }
    }
    
    // Sites - private to each user
    match /sites/{siteId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.owner_id;
    }
    
    // Device configurations - private to each user
    match /devices/{deviceId} {
      allow read, update, delete: if request.auth != null && request.auth.uid == resource.data.owner_id;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.owner_id;
    }

    // ==================== Learning System Collections ====================

    // Pattern Usage Tracking - append-only logs with retention
    match /users/{userId}/pattern_usage/{usageId} {
      // Users can read their own usage data
      allow read: if isOwner(userId);

      // Users can create usage events
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['created_at', 'source']) &&
        request.resource.data.created_at is timestamp &&
        request.resource.data.source is string;

      // SECURITY: Allow deletion only for old records (90+ days for retention policy)
      // This allows cleanup functions to work
      allow delete: if isOwner(userId) &&
        resource.data.created_at < request.time - duration.value(90, 'd');

      // No updates (usage is append-only for auditing)
      allow update: if false;
    }

    // Favorites Collection
    match /users/{userId}/favorites/{favoriteId} {
      // Users can read their own favorites
      allow read: if isOwner(userId);

      // Users can create favorites
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['pattern_name', 'added_at']) &&
        request.resource.data.pattern_name is string &&
        request.resource.data.added_at is timestamp;

      // Users can update their favorites (usage count, last_used)
      allow update: if isOwner(userId) &&
        request.resource.data.pattern_name == resource.data.pattern_name &&
        request.resource.data.added_at == resource.data.added_at;

      // Users can delete their favorites
      allow delete: if isOwner(userId);
    }

    // Smart Suggestions Collection
    match /users/{userId}/suggestions/{suggestionId} {
      // Users can read their own suggestions
      allow read: if isOwner(userId);

      // Users can create suggestions (from client-side learning)
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['created_at', 'type', 'title']) &&
        request.resource.data.created_at is timestamp;

      // Users can update to dismiss suggestions
      allow update: if isOwner(userId) &&
        request.resource.data.dismissed == true;

      // Users can delete old suggestions
      allow delete: if isOwner(userId);
    }

    // Detected Habits Collection
    match /users/{userId}/detected_habits/{habitId} {
      // Users can read their detected habits
      allow read: if isOwner(userId);

      // Users can create habits (from client-side analysis)
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['detected_at', 'type', 'description']) &&
        request.resource.data.detected_at is timestamp;

      // No updates (habits are immutable once detected)
      allow update: if false;

      // SECURITY: Allow deletion for old habits (90+ days for retention policy)
      allow delete: if isOwner(userId) &&
        resource.data.detected_at < request.time - duration.value(90, 'd');
    }

    // Pattern Feedback subcollection (user's own feedback)
    match /users/{userId}/pattern_feedback/{feedbackId} {
      // Users can read their own feedback
      allow read: if isOwner(userId);

      // Users can create feedback
      allow create: if isOwner(userId) &&
        request.resource.data.keys().hasAll(['pattern_name', 'rating', 'created_at']) &&
        request.resource.data.rating is int &&
        request.resource.data.rating >= 1 &&
        request.resource.data.rating <= 5;

      // No updates or deletes (feedback is append-only for consistency)
      allow update, delete: if false;
    }

    // ==================== Global Analytics Collections ====================
    // These collections aggregate anonymized data across all users

    // Global Pattern Statistics
    match /analytics/global_pattern_stats/patterns/{patternId} {
      // Anyone can read trending patterns (public data)
      allow read: if request.auth != null;

      // Authenticated users can contribute stats (increment counters)
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['pattern_name', 'total_applications']);

      // No deletes (only Cloud Functions can clean up)
      allow delete: if false;

      // User tracking subcollection (hashed IDs for uniqueness)
      match /users/{hashedUserId} {
        allow read: if false; // Private tracking data
        allow write: if request.auth != null; // Any auth user can update
        allow delete: if false;
      }
    }

    // Pattern Feedback Aggregation
    match /analytics/pattern_feedback/patterns/{patternId} {
      // Anyone can read feedback stats
      allow read: if request.auth != null;

      // Authenticated users can contribute feedback
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['pattern_name', 'total_ratings']);

      allow delete: if false;

      // Anonymous rater tracking
      match /raters/{hashedUserId} {
        allow read: if false;
        allow write: if request.auth != null;
        allow delete: if false;
      }
    }

    // Pattern Requests
    match /analytics/pattern_requests/requests/{requestId} {
      // Anyone can read pattern requests
      allow read: if request.auth != null;

      // Authenticated users can create requests
      allow create: if request.auth != null &&
        request.resource.data.keys().hasAll(['requested_theme', 'created_at', 'vote_count', 'fulfilled']) &&
        request.resource.data.vote_count == 1 &&
        request.resource.data.fulfilled == false;

      // Users can vote (increment vote_count)
      allow update: if request.auth != null &&
        request.resource.data.vote_count == resource.data.vote_count + 1;

      // No deletes (only admins via Cloud Functions)
      allow delete: if false;

      // Voter tracking
      match /voters/{hashedUserId} {
        allow read: if false;
        allow write: if request.auth != null;
        allow delete: if false;
      }
    }

    // Color Trends
    match /analytics/color_trends/weekly/{weekId} {
      // Anyone can read color trends
      allow read: if request.auth != null;

      // Authenticated users can contribute color usage
      allow create, update: if request.auth != null;

      allow delete: if false;
    }

    // Effect Popularity
    match /analytics/effect_popularity/effects/{effectId} {
      // Anyone can read effect popularity
      allow read: if request.auth != null;

      // Authenticated users can contribute effect usage
      allow create, update: if request.auth != null &&
        request.resource.data.keys().hasAll(['effect_id', 'usage_count']);

      allow delete: if false;
    }

    // Trending Reports (generated by Cloud Functions)
    match /analytics/trending_reports/{reportId} {
      // Anyone can read reports
      allow read: if request.auth != null;

      // Only Cloud Functions can create reports
      allow write: if false;
    }

    // SECURITY: OAuth codes and refresh tokens collections (server-side only)
    match /oauth_codes/{codeId} {
      allow read, write: if false; // Only Cloud Functions can access
    }

    match /oauth_refresh_tokens/{tokenId} {
      allow read, write: if false; // Only Cloud Functions can access
    }
  }
}
